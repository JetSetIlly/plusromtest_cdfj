//==============================================================================
// Collect3 ARM routines
//--------------------------------------
// Last Update:  February 11, 2020
//               Darrell Spice, Jr.
//
//  Super simple game of "collect the objects" used to show how to develop
//  an Atari 2600 homebrew game using CDFJ.
//
//  More information available here:
//  https://atariage.com/forums/forum/262-cdfj/
//
//  Change Log
//  2019-12-15  initial version
//  2019-12-19  source improvements
//  2020-01-20  console detection
//  2020-02-08  menu
//  2020-02-11  score & timer display
//==============================================================================



//==============================================================================
// Includes
//--------------------------------------
//  defines_cdfj.h
//      defines and functions for CDFJ coprocessor
//  defines_from_dasm_for_c.h
//      auto-generated by the make file, it contains values from the 6507 code
//  defines.h
//      defines to make the code easier to read
//==============================================================================

#include "defines_cdfj.h"
#include "defines_from_dasm_for_c.h"
#include "defines.h"



//==============================================================================
// Variables
//--------------------------------------
// The Harmony/Melody does not support floating point values, so we can only
// use data types of char and int. These types can be modified with unsigned
// and/or short to change the range of values that can be represented.
//
// signed char        =  8 bit, 1 byte,  range is           -128 to           127
// char               =  8 bit, 1 byte,  range is              0 to           255
// unsigned char      =  8 bit, 1 byte,  range is              0 to           255
// short int          = 16 bit, 2 bytes, range is        -32,768 to        32,767
// unsigned short int = 16 bit, 2 bytes, range is              0 to        65,535
// int                = 32 bit, 4 bytes, range is -2,147,483,648 to 2,147,483,647
// unsigned int       = 32 bit, 4 bytes, range is              0 to 4,294,967,295
//
// NOTE: variables of int and unsigned int result in smaller/faster code, but
// are not always practical to use due to limited amount of RAM available.
//==============================================================================

unsigned int frame;
unsigned char player_x[2];
unsigned char player_y[2];
unsigned short int player_shape[2];

unsigned char is_7800;  // 0 = 2600, non-zero = 7800

// Image Data
short int *image_graphics       =(short int *)(ROM+_IMAGE_GRAPHICS);
short int *image_colors         =(short int *)(ROM+_IMAGE_COLORS);
unsigned char *image_heights    =(unsigned char *)(ROM+_IMAGE_HEIGHTS);

// Menu Data
short int *menu_graphics_offset =(short int *)(ROM+_MENU_GRAPHICS_OFFSET);
unsigned char mm_selected_option;
unsigned char mm_tv_type;  // 0 = NTSC, 1 = PAL, 2 = SECAM
unsigned char mm_joystick_timer;
unsigned char mm_fire_down;
unsigned char mm_players;
unsigned char mm_arena;
unsigned char mm_option1;
unsigned char mm_option2;



//==============================================================================
// Function Prototypes
//--------------------------------------
// Functions should be defined before they can be used. One way to do that is to
// build the program from the bottom of the file upward, putting function main()
// at the end of the file.
//
// The other way to do that is to define funtion prototypes, which allow you
// to put the actual functions in the file in any order. We will use this way.
//
// A function prototype defines the return value and whether or not the function
// takes any parameters.
//
// Note: void is used for functions without a return value. They use less ROM
//       than the default return value of int.
//==============================================================================

void ChangeMenuOption(unsigned int graphic48,       // first byte of option graphics
                      unsigned int startingcolumn,  // column to start changing
                      unsigned int newgraphic,      // first byte of new graphic
                      unsigned int columns);        // number of columns to change
void CheckConsoleSwitches();
int ColorConvert(int);
void GameOverScan();
void GameVerticalBlank();
void Initialize();
void MenuOverScan();
void MenuVerticalBlank();
void NewGame();
void PrepGameDatastreams();
void PrepScoreDatastreams();
void ProcessGameJoystick();
void ProcessMenuJoystick();
void SplashOverScan();
void SplashVerticalBlank();
void TurnOptionRed(int);



//==============================================================================
// Function Definitions
//--------------------------------------
// main() is the initial function called when running C code. Main is defined as
// returning an int value. You could change it to void and it will still work;
// however, it will introduce compile time warnings, and unlike using void for
// other functions using void for main() will not save any ROM.
//==============================================================================

int main()
{
    // main() is called when the 6507 code writes to CALLFN
    
    switch(RUN_FUNC)
    {
        case _FN_INIT:      Initialize();           break;
        case _FN_GAME_OS:   GameOverScan();         break;
        case _FN_GAME_VB:   GameVerticalBlank();    break;
        case _FN_MENU_OS:   MenuOverScan();         break;
        case _FN_MENU_VB:   MenuVerticalBlank();    break;
        case _FN_SPLASH_OS: SplashOverScan();       break;
        case _FN_SPLASH_VB: SplashVerticalBlank();  break;
    }
    
    return 0;
}

void Initialize()
{
    int i;
    
    // during Initialize() SWCHA contains the results of the 6507 routine which
    // detects if the console is a 2600 or 7800
    is_7800 = SWCHA;    // 0 = 2600, non-zero = 7800
    
    mm_selected_option = _MENU_START_ID;
    
    // When powered up the 4K of Display Data RAM will contain random values,
    // so zero it out.  myMemsetInt is faster than using myMemset, but
    // requires dividing the number of bytes by 4.
    myMemsetInt(RAM_INT, 0, 4096/4);
    
    // likewise the datastream increments will be random, so set them to 1.0
    for(i=0;i<=34;i++)
        setIncrement(i,1,0);
}



//==============================================================================
// Splash routines
//--------------------------------------
//  All splash logic runs in OverScan
//  All prep of the datastreams runs in Vertical Blank
//==============================================================================

void SplashOverScan()
{
    // Splash does not call CheckConsoleSwitches, so we need to increment the
    // frame counter at start of OverScan
    frame++;
    
    // exit Splash Screen after about 2 seconds
    if (frame & 128)
        MODE = 1;
    
    // this will eventually include:
    //  - AtariAge jingle
    //  - ability to press fire to abort Splash
}

void SplashVerticalBlank()
{
    int i;
    int j;
    int color;
    int console;
    
    color = 0;  // default to black

    // used to show if the console is a 2600 or 7800
    console = ((is_7800 ? _SPLASH_78 : _SPLASH_26 ) & 0xfff) + 0x6000;
    
    if (frame == 1)         // frame is incremented in SplashOverScan()
    {
        T1TC = 0;           // make sure timer starts at 0
        T1TCR = 1;          // turn on timer
    }
    else if (frame == 2)
    {
        T1TCR = 0;          // turn off timer after 1 frame
        
        // the time it takes to output 262 scanlines is different for
        // NTSC, PAL, and SECAM consoles, so we can use that to detect
        // which one and adjust the color values.
        if (T1TC < (0x11e8ff + 0x11d329)/2)
            mm_tv_type = NTSC;
        else if (T1TC > (0x11fd2b + 0x11e8ff)/2)
            mm_tv_type = PAL;
        else
            mm_tv_type = SECAM;
    }
    else if (frame >= 12)
    {
        // give image time to stablize before showing it
        color = ColorConvert(_RED + 4);
    }
    
    // j will be 0, 1, ..., 7 over subsequent frames. Used to scroll SPLASH
    j = frame & 7;
    
    // fill the datastreams with the graphics of SPLASH.
    // Note: since entire datastream gets filled, we do not need to zero it out
    //       like we do in GameVerticalBlank
    for(i=0;i<192;i++)
    {
        RAM[_BUF_SPLASH0 + i] = ROM[ (_SPLASH_GFX0 & 0xfff) + 0x6000 + j];
        RAM[_BUF_SPLASH1 + i] = ROM[ (_SPLASH_GFX1 & 0xfff) + 0x6000 + j];
        RAM[_BUF_SPLASH2 + i] = ROM[ (_SPLASH_GFX2 & 0xfff) + 0x6000 + j];
        RAM[_BUF_SPLASH3 + i] = ROM[ console + j];
        
        j++;
        j &= 7;
    }
    
    // initialize the Data Streams for 6507 code
    setPointer(_DS_SPLASH_P0L, _BUF_SPLASH0);
    setPointer(_DS_SPLASH_P1L, _BUF_SPLASH1);
    setPointer(_DS_SPLASH_P0R, _BUF_SPLASH2);
    setPointer(_DS_SPLASH_P1R, _BUF_SPLASH3);
    
    // set the X positions of the players
    P0_X = 64;
    P1_X = 72;
    
    // set color
    TEMP_COLOR = color;
}



//==============================================================================
// Menu routines
//--------------------------------------
//  All menu logic will run in OverScan
//  All prep of the datastreams runs in Vertical Blank
//==============================================================================

void MenuOverScan()
{
    CheckConsoleSwitches();
    
    // only check joystick if user did not press GAME RESET
    if (MODE == 1)
        ProcessMenuJoystick();
}

void MenuVerticalBlank()
{
    int i;
    
    // copy Menu Graphics, Menu Control, and NTSC Menu Colors from ROM as the
    // RAM is repurposed during the game.
    myMemcpy((unsigned char *)RAM + _BUF_MENU_GRAPHICS,
             (unsigned char *)ROM + _MENU_GRAPHICS,
             _MENU_GRAPHICS_SIZE + _MENU_CONTROL_SIZE + _MENU_COLORS_SIZE);
    
    for(i = 0; i < _MENU_COLORS_SIZE; i++)
        RAM[_BUF_MENU_COLORS + i] = ColorConvert(RAM[_BUF_MENU_COLORS + i]);
    
    // Menu shows 1 player by default, change if required
    if (mm_players)
        ChangeMenuOption(menu_graphics_offset[_MENU_PLAYERS_ID], 5, _OPTION_2, 1);

    // Menu shows arena 1 by default, change if required
    switch(mm_arena)
    {
        case 1:
            ChangeMenuOption(menu_graphics_offset[_MENU_ARENA_ID], 5, _OPTION_2, 1);
            break;
            
        case 2:
            ChangeMenuOption(menu_graphics_offset[_MENU_ARENA_ID], 5, _OPTION_3, 1);
            break;
            
        case 3:
            ChangeMenuOption(menu_graphics_offset[_MENU_ARENA_ID], 5, _OPTION_4, 1);
            break;
    }
    
    // Menu shows checked by default, change if required
    if (!mm_option1)
    {
        ChangeMenuOption(menu_graphics_offset[_MENU_OPTION1_ID], 5, _OPTION_UNCHECKED, 1);
        TurnOptionRed(_MENU_OPTION1_ID);
    }
    
    // Menu shows checked by default, change if required
    if (!mm_option2)
    {
        ChangeMenuOption(menu_graphics_offset[_MENU_OPTION2_ID], 5, _OPTION_UNCHECKED, 1);
        TurnOptionRed(_MENU_OPTION2_ID);
    }
    
    // Menu shows NTSC by default, change if required
    switch (mm_tv_type)
    {
        case PAL:
            ChangeMenuOption(menu_graphics_offset[_MENU_TV_TYPE_ID], 4, _OPTION_PAL, 2);
            break;
            
        case SECAM:
            ChangeMenuOption(menu_graphics_offset[_MENU_TV_TYPE_ID], 3, _OPTION_SECAM, 3);
            break;
    }
    
    // flash selected option
    for(i=0;i<14;i+=2)
        RAM[_BUF_MENU_COLORS +                          // beginning of menu colors
            (_MENU_LOGO_HEIGHT-_MM_OPTION_HEIGHT)*2 +   // skip past game logo colors (2 per scanline)
            mm_selected_option*_MM_OPTION_HEIGHT*2 +    // skip to selected option
            i + 1] = frame;
    
    // initialize the Data Streams for 6507 code
    setPointer(_DS_MENU_GRAPHICS,   _BUF_MENU_GRAPHICS);
    setPointer(_DS_MENU_CONTROL,    _BUF_MENU_CONTROL);
    setPointer(_DS_MENU_COLORS,     _BUF_MENU_COLORS);
    
    // set the X positions of the objects for the 48 pixel display
    P0_X = 0x38;
    P1_X = 0x40;
    M0_X = 17;
    M1_X = 105;
    BALL_X = 0;    
}

void ChangeMenuOption(unsigned int graphic48,       // first byte of option graphics
                      unsigned int startingcolumn,  // column to start changing
                      unsigned int newgraphic,      // first byte of new graphic
                      unsigned int columns)         // number of columns to change
{
    int r, c;
    for (r=0;r<_MM_OPTION_HEIGHT;r++)
        for(c=0;c<columns;c++)
            RAM[graphic48 + startingcolumn + c + r*6] = ((unsigned char *)( ROM+newgraphic ))[c + r*columns];
}

void ProcessGameJoystick()
{
    // left player
    if (JOY0_RIGHT)
        if (player_x[0] < 152)
        {
            player_x[0]++;
            player_shape[0] = 0;
        }
    
    if (JOY0_LEFT)
        if (player_x[0] > 0)
        {
            player_x[0]--;
            player_shape[0] = 1;
        }
    
    if (JOY0_DOWN)
        if (player_y[0] < _ARENA_HEIGHT - 16)
            player_y[0]++;
    
    if (JOY0_UP)
        if (player_y[0] > 0)
            player_y[0]--;
    
    // right player
    if (JOY1_RIGHT)
        if (player_x[1] < 152)
        {
            player_x[1]++;
            player_shape[1] = 0;
        }
    
    if (JOY1_LEFT)
        if (player_x[1] > 0)
        {
            player_x[1]--;
            player_shape[1] = 1;
        }
    
    if (JOY1_DOWN)
        if (player_y[1] < _ARENA_HEIGHT - 16)
            player_y[1]++;
    
    if (JOY1_UP)
        if (player_y[1] > 0)
            player_y[1]--;
}

void ProcessMenuJoystick()
{
    
    if (JOY0_FIRE)
    {
        mm_fire_down = 1;
    }
    else
    {
        if (mm_fire_down) // if fire button was released
        {
            mm_fire_down = 0;
            // start a new game if start option is selected
            if (mm_selected_option == _MENU_START_ID)
                NewGame();
        }
    }
    
    // joystick timer controls auto-change of values when fire is held
    if (JOY0_NOTHING && !mm_fire_down)
    {
        mm_joystick_timer = 0;
    }
    else
    {
        mm_joystick_timer++;
        mm_joystick_timer &= 0x0f;  // makes timer = 0 when it reaches 16
                                    // use 0x1f for a slower auto-change.
    }
    
    if (mm_joystick_timer == 1)
    {
        // if joystick up and fire not pressed then change selected option
        if (JOY0_UP && !mm_fire_down)
        {
            if (mm_selected_option == _MENU_FIRST_OPTION_ID)
                mm_selected_option = _MENU_START_ID;
            else
                mm_selected_option--;
            return;
        }
        // if joystick down and fire not pressed then change selected option
        if (JOY0_DOWN && !mm_fire_down)
        {
            if (mm_selected_option == _MENU_START_ID)
                mm_selected_option = _MENU_FIRST_OPTION_ID;
            else
                mm_selected_option++;
            return;
        }
        
        if (JOY0_LEFT)  // joystick left decrements selected option
        {
            switch (mm_selected_option)
            {
                case _MENU_PLAYERS_ID:
                    mm_players ^= 1;
                    break;
                    
                case _MENU_ARENA_ID:
                    mm_arena--;
                    mm_arena &= 0x03;
                    break;

                case _MENU_OPTION1_ID:
                    mm_option1 ^= 1;
                    break;
                    
                case _MENU_OPTION2_ID:
                    mm_option2 ^= 1;
                    break;
                    
                case _MENU_TV_TYPE_ID:
                    if (mm_tv_type == 0)    mm_tv_type = 2;
                    else                    mm_tv_type--;
                    break;
            }
        }
        else if (JOY0_RIGHT || mm_fire_down)    // joystick right OR fire increments selected option
        {
            switch (mm_selected_option)
            {
                case _MENU_PLAYERS_ID:
                    mm_players ^= 1;
                    break;
                    
                case _MENU_ARENA_ID:
                    mm_arena++;
                    mm_arena &= 0x03;
                    break;
                    
                case _MENU_OPTION1_ID:
                    mm_option1 ^= 1;
                    break;
                    
                case _MENU_OPTION2_ID:
                    mm_option2 ^= 1;
                    break;                
                    
                case _MENU_TV_TYPE_ID:
                    if (mm_tv_type == 2)    mm_tv_type = 0;
                    else                    mm_tv_type++;
                    break;
            }
        }
    }
}

//==============================================================================
// Game routines
//--------------------------------------
//  All game logic runs in OverScan
//  All prep of the datastreams runs in Vertical Blank
//==============================================================================

void GameOverScan()
{
    CheckConsoleSwitches();
    if (MODE == 128)
    {
        ProcessGameJoystick();
    }
}

const unsigned char arena_color[4] =
{
        _BLACK,
        _RED,
        _GREEN,
        _BLUE
};

void GameVerticalBlank()
{
    // Zero out the datastreams.  It's fastest to use myMemsetInt, but requires
    // proper alignment of the data streams (the ALIGN 4 pseudops found in the
    // 6507 code). Additionally the offset(_GameZeroOutStart) and
    // byte count(_GameZeroOutBytes) must both be divided by 4.
    myMemsetInt(RAM_INT + _GameZeroOutStart/4, 0, _GameZeroOutBytes/4);

    PrepGameDatastreams();
    PrepScoreDatastreams();
}

void NewGame()
{
    // tells 6507 code to use the game kernels
    MODE = 128;
    
    // set starting positions for the players
    player_x[0] = 36;   player_y[0] = 40;   player_shape[0] = 0;
    player_x[1] = 116;  player_y[1] = 136;  player_shape[1] = 1;
}


//==============================================================================
// Subroutines
//==============================================================================

void CheckConsoleSwitches()
{
    // Main purpose of this function is to check the console switches and
    // react accordinging.  Since the Menu and Game routines both use this,
    // we save some ROM by handling frame counter and random call here
    frame++;
    
    // "Random numbers" are not really random. By retreiving and discarding a
    // number every frame we add a human element to the randomness
    getRandom32();
   
    // check the SELECT and RESET console switches,
    // if pressed make the approriate action
    if      (GAME_SELECT_PRESSED)   MODE = 1;   // show the main menu
    else if (GAME_RESET_PRESSED)    NewGame();  // start new game
}


const unsigned char NTSCtoPAL[16] =
{
    // SeaGtGruff's conversion values from this post at AtariAge:
    // https://atariage.com/forums/topic/165424-modify-colour-palette/?do=findComment&comment=2043124
    0x00, 0x20, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0,
    0xd0, 0xb0, 0x90, 0x70, 0x50, 0x30, 0x30, 0x20
};

const unsigned char NTSCtoSECAM[16] =
{
    0x0e,   // 0 = white            e = white
    0x0c,   // 1 = yellow           c = yellow
    0x0c,   // 2 = yellowish orange c = yellow
    0x04,   // 3 = reddish orange   4 = red
    0x04,   // 4 = red              4 = red
    0x06,   // 5 = reddish purple   6 = purple
    0x06,   // 6 = purple           6 = purple
    0x06,   // 7 = bluish purple    6 = purple
    0x02,   // 8 = blue             2 = blue
    0x02,   // 9 = blue             2 = blue
    0x0a,   // a = bluish cyan      a = cyan
    0x0a,   // b = cyan             a = cyan
    0x08,   // c = green            8 = green
    0x08,   // d = green            8 = green
    0x08,   // e = olive green      8 = green
    0x0c    // f = brown            c = yellow
};

int ColorConvert(int color)
{
    if (mm_tv_type == PAL)
    {
        return NTSCtoPAL[color>>4] +    // convert chroma value
               (color & 0x0f);          // retain luma value
    }
    else if (mm_tv_type == SECAM)
    {
        if (color < 2)
            return 0;   // return black for 0 or 1
        else
            return NTSCtoSECAM[color>>4];
    }
    else
        return color;
}

void MergeCharacters(int datastream, int left_character, int right_character)
{
    int i;
    unsigned char *stream = RAM + datastream;
    unsigned char *left = ROM + _FONT + left_character * _FONT_HEIGHT;
    unsigned char *right = ROM + _FONT + right_character * _FONT_HEIGHT;
    
    for (i=0;i<7;i++)
        *stream++ = ((*left++) & 0xf0) + ((*right++) & 0x0f);
}

void PrepGameDatastreams()
{
    int i;
    unsigned char * color;
    
    // Use Y value to position graphics for player 0 in the datastream
    myMemcpy(RAM + _BUF_PLAYER0 + player_y[0], ROM + image_graphics[player_shape[0]], image_heights[0]);
    
    color = ROM + image_colors[0];
    for (i=0;i<16;i++)
        RAM[_BUF_COLOR0  + player_y[0] + i] = ColorConvert(color[i]);
    
    if (mm_players) // only draw if 2 player game
    {
        // Use Y value to position graphics for player 1 in the datastream
        myMemcpy(RAM + _BUF_PLAYER1 + player_y[1], ROM + image_graphics[player_shape[1]], image_heights[1]);
        
        color = ROM + image_colors[1];
        for (i=0;i<16;i++)
            RAM[_BUF_COLOR1  + player_y[1] + i] = ColorConvert(color[i]);
    }
    
    // initialize the Data Streams for 6507 code
    setPointer(_DS_GRP0, _BUF_PLAYER0);
    setPointer(_DS_GRP1, _BUF_PLAYER1);
    setPointer(_DS_COLUP0, _BUF_COLOR0);
    setPointer(_DS_COLUP1, _BUF_COLOR1);
    
    // set the X positions of the players
    P0_X = player_x[0];
    P1_X = player_x[1];
    
    TEMP_COLOR = ColorConvert(arena_color[mm_arena]);
}

void PrepScoreDatastreams()
{
    
    if (LEFT_DIFFICULTY_A && RIGHT_DIFFICULTY_B)
    {
        // show test pattern
        myMemcpy(RAM + _BUF_SCORE0_A,
                 ROM + _TEST_PATTERN,
                 6 * 7);   // six datastreams of 7 bytes each
    }
    else if (LEFT_DIFFICULTY_B && RIGHT_DIFFICULTY_A)
    {
        // show VB and OS Time Remaining
        MergeCharacters(_BUF_SCORE0_A,  _FONT_VB,       _FONT_VB);
        MergeCharacters(_BUF_SCORE0_B,  VB_TIME>>4,     VB_TIME & 0x0f);
        
        MergeCharacters(_BUF_TIMERA,    _FONT_SPACE,    _FONT_SPACE);
        MergeCharacters(_BUF_TIMERB,    _FONT_SPACE,    _FONT_SPACE);
        
        MergeCharacters(_BUF_SCORE1_A,  _FONT_OS,       _FONT_OS);
        MergeCharacters(_BUF_SCORE1_B,  OS_TIME>>4,     OS_TIME & 0x0f);
    }
    else if (LEFT_DIFFICULTY_A && RIGHT_DIFFICULTY_A)
    {
        // show player positions
        MergeCharacters(_BUF_SCORE0_A,  (player_x[0] >> 4) & 0x0f,  player_x[0] & 0x0f);
        MergeCharacters(_BUF_SCORE0_B,  (player_y[0] >> 4) & 0x0f,  player_y[0] & 0x0f);
        
        MergeCharacters(_BUF_TIMERA, _FONT_SPACE, _FONT_YX);
        MergeCharacters(_BUF_TIMERB, _FONT_YX, _FONT_SPACE);
        
        if (mm_players)
        {
            MergeCharacters(_BUF_SCORE1_A,  (player_x[1] >> 4) & 0x0f,  player_x[1] & 0x0f);
            MergeCharacters(_BUF_SCORE1_B,  (player_y[1] >> 4) & 0x0f,  player_y[1] & 0x0f);
        }
        else
        {
            MergeCharacters(_BUF_SCORE1_A, _FONT_SPACE, _FONT_SPACE);
            MergeCharacters(_BUF_SCORE1_B, _FONT_SPACE, _FONT_SPACE);
        }
    }
    else
    {
        // show score, using FRAME as test for now
        MergeCharacters(_BUF_SCORE0_A, (frame >> 28) & 0x0f, (frame >> 24) & 0x0f);
        MergeCharacters(_BUF_SCORE0_B, (frame >> 20) & 0x0f, (frame >> 16) & 0x0f);
        
        MergeCharacters(_BUF_TIMERA, 2, _FONT_COLON);
        MergeCharacters(_BUF_TIMERB, 0, 0);
        
        MergeCharacters(_BUF_SCORE1_A, (frame >> 12) & 0x0f, (frame >> 8) & 0x0f);
        MergeCharacters(_BUF_SCORE1_B, (frame >> 4) & 0x0f, frame & 0x0f);

    }

    SCORE0_COLOR = ColorConvert(_BLUE + 6);
    SCORE1_COLOR = ColorConvert(_GREEN + 6);

    // initialize the Data Streams for 6507 code
    setPointer(_DS_SCORE0_GFXA,     _BUF_SCORE0_A);
    setPointer(_DS_SCORE0_GFXB,     _BUF_SCORE0_B);
    setPointer(_DS_TIMER_GFXA,      _BUF_TIMERA);
    setPointer(_DS_TIMER_GFXB,      _BUF_TIMERB);
    setPointer(_DS_SCORE1_GFXA,     _BUF_SCORE1_A);
    setPointer(_DS_SCORE1_GFXB,     _BUF_SCORE1_B);
    
    setPointer(_DS_SCORE0_COLOR,    _BUF_SCORE0_COLOR);
    setPointer(_DS_SCORE1_COLOR,    _BUF_SCORE1_COLOR);
    
    // an increment of 0.0 causes the datastream to always return the same value
    setIncrement(_DS_SCORE0_COLOR, 0, 0);
}

void TurnOptionRed(int optionID)
{
    int i;
    for(i=0;i<14;i++)
        RAM[_BUF_MENU_COLORS +                      // beginning of menu colors
            (_MENU_LOGO_HEIGHT-_MM_OPTION_HEIGHT)*2 // skip past game logo colors (2 per scanline)
            + optionID*_MM_OPTION_HEIGHT*2          // skip to selected option
            + i] = ColorConvert(ROM[_OPTION_RED + i]);
}
